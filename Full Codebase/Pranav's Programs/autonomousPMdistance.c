#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     infrared,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touch,          sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorTetrix, openLoop, encoder) //reversed, encoder
#pragma config(Motor,  mtr_S1_C1_2,     Right,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     Left2,         tmotorTetrix, openLoop) //,reversed)
#pragma config(Motor,  mtr_S1_C3_2,     Right2,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     Lift1,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Lift2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     Sweep,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    pin,                  tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//NEVER EVER COPY THE CONFIGS FROM THIS PROGRAM
//EVER
//If YOU NEED CONFIGS, GET THEM FROM DRIVENOACCEL
//NOT THIS
//I CANNOT EMPHASIZE THIS ENOUGH

//version 6.0.1 alpha

#include "JoystickDriver.c"

int delay = 0;//set this number to the delay in seconds

//initializing all procedures that are used
	void resetEncoders();
	void initializeRobot();
	void moveForward(float power);
	void brake();
	void dumpCube();
	void turn(float power);

//initializing all functions that are used
	float distanceTravelled();
	float encoderDifference();

//initializing all tasks that are used
	task liftUp();
	task liftDown();

//initializing all the global integers that are used
	int liftUpTime = 1750;
	int liftDownTime = 1300;
	int dir = -1;

//initializing all the global floats that are used
	float in = 360/PI;
	float turnRightTime = .5;
	float turnLeftTime = .5;

//initializing all the global booleans that are used
	bool liftedUp = false;
	bool foundCrate = false;

//initializing all the arrays that are used
	float irDistances[4] = {18.5, 10, 19, 10};
	float irBackDistances[4] = {16.5, 8, 17, 8};
	int irValues[4] = {5, 5, 4, 4};

task main(){

	int crateVal = 0;//initializes the value that will be set to the crate which has the IR beacon

	resetEncoders();//sets the wheel encoders to zero
	initializeRobot();//initializes the robot

	waitForStart();//waits until the start signal

	wait1Msec(delay*1000);//waits the number of seconds set by the program
	wait1Msec(500);//slight delay

	moveForward(-30);//starts moving backwards

	StartTask(liftUp);//start moving the lift up while the program runs

	for (int currentCrate = 0; currentCrate < 4; currentCrate++){//runs through the next block four times or until it finds the beacon
		while (distanceTravelled() <= irDistances[currentCrate]){}//waits until the robot is at each bucket

		if (SensorValue(infrared) == irValues[currentCrate]){//checks to see if the robot is at the bucket with the beacon
			foundCrate = true;
			crateVal = currentCrate+1;//sets the global variable that shows the rest of the program where the beacon is
			brake();//stops the robot
			wait1Msec(500);//slight delay
			break;//breaks out of the for loop
		}
		resetEncoders();//resets the encoders after every basket
	}

	resetEncoders();//resets the encoders again
	brake();//stops the robot in case the first one didn't work

	if (!foundCrate){//runs through if the sensor did not find the beacon
		crateVal = 4;//the robot is at the fourth bucjet if it did not find the beacon anywhere else
	}

	while (!liftedUp){wait1Msec(10);}//waits if the lift is not all the way up yet
	StopTask(liftUp);//stops the task after the lift is up

	dumpCube();//dumps the cube

	wait1Msec(500);//slight delay

	StartTask(liftDown);//starts dropping the lift

	moveForward(60);//move forward towards the starting position

	resetEncoders();
	while (distanceTravelled() <= irBackDistances[crateVal-1]){}//wait until the robot is two inches away from the wall

	brake();//stop two inches away from the wall

	turn(50);//turn right at half power

	wait1Msec(turnRightTime*1000);//turn right for the correct number of seconds

	brake();//stop

	wait1Msec(500);//slight delay

	resetEncoders();//set encoders to zero
	while (distanceTravelled() <= 24){//wait until the robot moves two feet
		moveForward(50);//move forward at half power
	}

	wait1Msec(500);//slight delay

	turn(-50);//turn left

	wait1Msec(turnLeftTime);//wait the correct number of seconds

	brake();//stop

	wait1Msec(500);//slight delay

	resetEncoders();//set encoders to zero
	while (distanceTravelled() <= 36){//wait until robot has moved three feet
		moveForward(-100);//move backward at full power
	}

	brake();//stop


}

task liftUp(){
	motor[Lift1] = 100;
	motor[Lift2] = 100;
	wait1Msec(liftUpTime);
	motor[Lift1] = 0;
	motor[Lift2] = 0;
	liftedUp = true;
	EndTimeSlice();
}

task liftDown(){
	motor[Lift1] = -100;
	motor[Lift2] = -100;
	wait1Msec(liftDownTime);
	motor[Lift1] = 0;
	motor[Lift2] = 0;
	EndTimeSlice();
}



void resetEncoders(){
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;
}

void initializeRobot(){
	brake();
	motor[Lift1] = 0;
	motor[Lift2] = 0;
	motor[Sweep] = 0;
	motor[Flag] = 0;
	servo[bucket] = 135;
	servo[pin] = 0;
}

void moveForward(float power){
	motor[Left] = -power;
	motor[Left2] = -power;
	motor[Right] = power;
	motor[Right2] = power;
}

void brake(){
	moveForward(0);
}

void dumpCube(){
	int servoMovement = 40;
	wait1Msec(50);
	servo[bucket] = 135;
	wait1Msec(50);
	servo[bucket] = 135 + (dir*servoMovement);
	wait1Msec(2000);
	servo[bucket] = 135;
	wait1Msec(50);
}

void turn(float power){
	motor[Left] = -power;
	motor[Left2] = -power;
	motor[Right] = -power;
	motor[Right2] = -power;
}

float distanceTravelled(){
	return((abs(nMotorEncoder[Left]+nMotorEncoder[Right])/2)/in);
}
float encoderDifference(){
	float left = nMotorEncoder[Left];
	float right = nMotorEncoder[Right];
	return(abs(left-right));
}
