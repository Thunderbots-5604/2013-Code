#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     infared,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touch,          sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Right,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     Left2,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     Right2,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     Lift1,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Lift2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     Sweep,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    pin,                  tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

//A continuously driving autonomous IR beacon finder that has multiple attempts at finding if the block is not found the first time
//Made by Daniel Grimshaw
//Last edited on 1/7/13 at 16:28:19
//Needs some values adding at line 234

//waiting variables
bool waitForOthers = false;//boolean for waiting for anyone else to do it
unsigned short maxWait = 5000;//approximate maximum wait time

float IN = 114.649682;
float DEG = 14.35;

//vars used for driving
static float accelerationFactor;
static short orientFactor;//in moves
static short leftMotorDirectionalFactor;//in turns
static short rightMotorDirectionalFactor;//in turns
static short leftMotorSpeedCorrectionFactor;
static short rightMotorSpeedCorrectionFactor;
static short globalSpeedCorrectionFactor = 6;
static long distanceTravelled;
static short RAISELIFTTIME = 1650;

void initializeRobot(){
	servo[bucket] = 135;
	servo[pin] = 0;
	motor[Lift1] = 0;
	motor[Lift2] = 0;
	motor[Left] = 0;
	motor[Left2] = 0;
	motor[Right] = 0;
	motor[Right2] = 0;
}

void correctLeft(){
	leftMotorSpeedCorrectionFactor = globalSpeedCorrectionFactor;
  rightMotorSpeedCorrectionFactor = 0;
}//correct if left is too fast

void correctRight(){
	leftMotorSpeedCorrectionFactor = 0;
  rightMotorSpeedCorrectionFactor = globalSpeedCorrectionFactor;
}//correct if right is too fast

void zeroEncoders(){
	distanceTravelled += abs((nMotorEncoder[Left] + nMotorEncoder[Right])/2);//take average for more accuracy
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;
}//zero encoders

void halt(){
	motor[Left] = 0;
	motor[Right] = 0;
	motor[Left2] = 0;
	motor[Right2] = 0;
	zeroEncoders();
}

void dumpCube(){
	motor[Lift1] = 100;
  motor[Lift2] = 100;
  wait1Msec(1750);
  motor[Lift1] = 0;
  motor[Lift2] = 0;
  wait10Msec(5);
  servo[bucket] = 240;
  wait1Msec(3501);
  servo[bucket] = 130;
  wait10Msec(100);
  motor[Lift1] = -100;
  motor[Lift2] = -100;
  wait1Msec(1250);
  motor[Lift1] = 0;
  motor[Lift2] = 0;
}//dump cube

void move(short power, float dist, bool ir, bool raiseLift){//"+" =foward  "-" =reverse for power, dist is in inches
	dist--;//might not be necessary
	orientFactor = 1;
	if (power < 0)
		orientFactor = -1;
	power = abs(power);
	dist = abs(dist*IN/3);
	if (raiseLift){
		ClearTimer(T1);
		motor[Lift1] = 100;
		motor[Lift2] = 100;
	}
	if (!raiseLift){
		ClearTimer(T1);
		motor[Lift1] = -100;
		motor[Lift2] = -100;
	}

	zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist)//acceleration
  {
  	accelerationFactor = 30+power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor > power)
  		accelerationFactor = power;

  	if (ir == true){
  		if (SensorValue[infared] == 4){
  			dist = 0;
  			halt();
  			zeroEncoders();
  			break;}
  	}//ir
  	if (raiseLift){
  		if (time1[T1] >= RAISELIFTTIME){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}
  	}//raising lift
  	if (!raiseLift){
  		if (!SensorValue[touch]){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}//bottom of lift
  	}

  	motor[Left] = orientFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right] = orientFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
   	motor[Left2] = orientFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right2] = orientFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
  }//acceleration
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist)//constant speed
  {
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (ir == true){
  		if (SensorValue[infared] == 4){
  			dist = 0;
  			halt();
  			zeroEncoders();
  			break;}
  	}
  	if (raiseLift){
  		if (time1[T1] >= RAISELIFTTIME){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}
  	}
  	if (!raiseLift){
  		if (!SensorValue[touch]){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}//bottom of lift
  	}

  	motor[Left] = orientFactor*(power-leftMotorSpeedCorrectionFactor);
   	motor[Right] = orientFactor*(power-rightMotorSpeedCorrectionFactor);
   	motor[Left2] = orientFactor*(power-leftMotorSpeedCorrectionFactor);
   	motor[Right2] = orientFactor*(power-rightMotorSpeedCorrectionFactor);
  }
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) <dist)//deceleration
  {
  	accelerationFactor = power-power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor < 5)
  		accelerationFactor = 5;

  	if (ir == true){
  		if (SensorValue[infared] == 4){
  			dist = 0;
  			halt();
  			zeroEncoders();
  			break;}
  	}
  	if (raiseLift){
  		if (time1[T1] >= RAISELIFTTIME){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}
  	}
  	if (!raiseLift){
  		if (!SensorValue[touch]){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}//bottom of lift
  	}

  	motor[Left] = orientFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right] = orientFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
   	motor[Left2] = orientFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right2] = orientFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
  }
  motor[Left] = 0;
  motor[Right] = 0;
  motor[Left2] = 0;
  motor[Right2] = 0;
}//move

void turn(int power, float dist){// "-" =left  "+" =right, dist is in inches
	leftMotorDirectionalFactor = 1;
	rightMotorDirectionalFactor = -1;
	if (power < 0){
		leftMotorDirectionalFactor = -1;
	  rightMotorDirectionalFactor = 1;
	}//turn left
	power = abs(power);
	dist = abs(dist*DEG/3);

	zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist){//acceleration
  	accelerationFactor = 50+power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor > power)
  		accelerationFactor = power;

  	motor[Left] = leftMotorDirectionalFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right] = rightMotorDirectionalFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
   	motor[Left2] = leftMotorDirectionalFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right2] = rightMotorDirectionalFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
  }//acceleration
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist){//constant speed
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	motor[Left] = leftMotorDirectionalFactor*(power-leftMotorSpeedCorrectionFactor);
   	motor[Right] = rightMotorDirectionalFactor*(power-rightMotorSpeedCorrectionFactor);
   	motor[Left2] = leftMotorDirectionalFactor*(power-leftMotorSpeedCorrectionFactor);
   	motor[Right2] = rightMotorDirectionalFactor*(power-rightMotorSpeedCorrectionFactor);
  }//static speed
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist){//deceleration
  	accelerationFactor = power-power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor < 50)
  		accelerationFactor = 50;

  	motor[Left] = leftMotorDirectionalFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right] = rightMotorDirectionalFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
   	motor[Left2] = leftMotorDirectionalFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right2] = rightMotorDirectionalFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
  }//deceleration
  motor[Left] = 0;
  motor[Right] = 0;
}//turn

task main(){
	initializeRobot();
  unsigned short wait = 75;
  unsigned short fieldLength = 70;
  bool rep = true;
  long bucketDistance;
	unsigned short attempts = 0;
	unsigned short attemptsNumber = 1;

	//wait for competition to begin
  waitForStart();

  if (waitForOthers == true)
  	wait1Msec(maxWait);
  while (rep == 1){//beacon search
  	attempts++;
  	move(-100, fieldLength, true, false);
  	wait1Msec(wait);
  	if (SensorValue[infared] == 4 || SensorValue[infared] == 5){
  		bucketDistance = distanceTravelled;
  		//returnDistance = distanceTravelled;
  		if (bucketDistance < 28*IN){
  			dumpCube();
  		}//first or second buckets
  		if (30.5*IN < bucketDistance){
  			dumpCube();
  		}//third or fourth buckets

  		//move(100, abs((returnDistance/IN)-7), false);
  		//move(100, 7, false)
  		//!!!!!!!!!!!!!!!possibly check if distance travelled is not greater than zero while moving!!!!!!
  		nxtDisplayCenteredTextLine(0, "First Search");
  		nxtDisplayCenteredTextLine(3, "%d", distanceTravelled);
  		wait10Msec(1500);
  		rep = false;
  	}//found bucket
  	distanceTravelled = 0;
  	if (SensorValue[infared] != 4 && SensorValue[infared] != 5 && SensorValue[infared] !=3 && SensorValue[infared] != 6){
  		move(100, fieldLength - 0.5, true, false);
  		if (SensorValue[infared] == 5){
  			bucketDistance = distanceTravelled;
  			//returnDistance = distanceTravelled;
  			if (bucketDistance < (25*IN)){
  				dumpCube();
  			}//first or second buckets
  			if ((27.5*IN) < bucketDistance){
  				dumpCube();
  			}//third or fourth buckets

  			nxtDisplayCenteredTextLine(0, "Second Search");
  			nxtDisplayCenteredTextLine(3, "%d", distanceTravelled);
  			wait10Msec(1500);
  			rep = false;
  		}//found bucket
  		wait1Msec(wait);
  	}//didn't find bucket

  	if (attempts == attemptsNumber)
  		rep = false;

  	if (waitForOthers == true)
  		rep = false;

  	wait1Msec(wait);
	}//beacon search
}
