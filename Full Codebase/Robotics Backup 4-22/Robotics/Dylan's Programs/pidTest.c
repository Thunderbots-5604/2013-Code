#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     infrared,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touch,          sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     left1,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     right1,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     left2,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     right2,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     lift1,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     lift2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     sweep,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    pin,                  tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/*
 * Variables for PID Tracking
 */
float kp1 = .04; //proportional gain
float ki1 = .0001; //integral gain
float kd1 = .01; //derivative gain
int trackingSpeed = 0;
float error = 0;
float totalError = 0;
float lastError = 0;
float integral = 0;
float derivative = 0;
float correction = 0;

//Set all the encoders back to zero
void clearEncoders() {
	nMotorEncoder[left1] = nMotorEncoder[right1] = 0;
}

//Makes setting motor speeds less of a hassle
void speeds(int a, int b, int c, int d){
	motor[left1] = a;
	motor[left2] = b;
	motor[right1] = c;
	motor[right2] = d;
}

task pidTracker() {
	clearEncoders();
	float l;
	float r;
	while(true) {
		l = (nMotorEncoder[left1]);
		r = (nMotorEncoder[right1]);
		error = l - r;
		totalError += error;
		derivative = error - lastError;
		lastError = error;
			correction = (kp1*error) + (ki1 * totalError) + (kd1 * derivative);

		writeDebugStreamLine("error: %d, totalerror: %d, deriv: %d, correction: %d", error, totalError, derivative, correction);

		motor[left1] = motor[left2] = (trackingSpeed - correction);
		motor[right1] = motor[right2] = (trackingSpeed + correction);
		wait1Msec(10);
	}
}

void pidTrack(int speed) {
	StopTask(pidTracker);
	speeds(0, 0, 0, 0);
	trackingSpeed = speed;
	error = 0;
	totalError = 0;
	lastError = 0;
	integral = 0;
	derivative = 0;
	correction = 0;
	if(speed != 0) {
		StartTask(pidTracker);
	}
}

task main() {
	pidTrack(80);
	clearEncoders();
	while(nMotorEncoder[left1] < 2800) {
		wait10Msec(1);
	}
	pidTrack(0);
	speeds(-50, -50, 50, 50);
	clearEncoders();
	while(nMotorEncoder[right1] < 2000) {
		wait10Msec(1);
	}
	speeds(0, 0, 0, 0);
	wait10Msec(10);
	if(SensorValue[infrared] <= 3) {
		pidTrack(-50);
		while(SensorValue[infrared] != 4) {
			wait10Msec(1);
		}
		pidTrack(0);
		ClearTimer(T1);
		motor[lift1] = 100;
		motor[lift2] = 100;
		while(time1[T1] < 1700) {
			wait10Msec(1);
		}
		motor[lift1] = 0;
		motor[lift2] = 0;
  	servo[bucket] = 245;
  	wait1Msec(1500);
  	servo[bucket] = 130;
  	wait10Msec(100);
	}
}
