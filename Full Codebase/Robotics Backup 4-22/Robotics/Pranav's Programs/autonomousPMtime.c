#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)//DON'T YOU COPY THESE CONFIGS
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     infared,        sensorHiTechnicIRSeeker1200)
#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)//DON'T YOU COPY THESE CONFIGS
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     infared,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touch,          sensorTouch)//I KNOW YOU WANT TO
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Right,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     Left2,         tmotorTetrix, openLoop)//DON'T DO IT
#pragma config(Motor,  mtr_S1_C3_2,     Right2,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     Lift1,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Lift2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     Sweep,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    pin,                  tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//NEVER EVER COPY THE CONFIGS FROM THIS PROGRAM
//EVER
//If YOU NEED CONFIGS, GET THEM FROM DRIVENOACCEL
//NOT THIS
//I CANNOT EMPHASIZE THIS ENOUGH

//version 6.0.1 alpha

#include "JoystickDriver.c"

int delay = 0;

void resetEncoders();
void initializeRobot();
void moveForward(float power);
void brake();
void adjust12();
void adjust34();
void dumpCube();
void turnLeft(float power);
void turnRight(float power);
float encoderDifference();

task liftUp();
task liftDown();

int liftUpTime = 1750;
int liftDownTime = 1300;
int adjustTime12 = 500;
int adjustTime34 = 500;
int dir = -1;

float turnTime = 1000; //time needed to turn 90 degrees
float footTime = 1000; //time needed to move one foot
float in = 360/PI;

short currentLeft = 0;
short currentRight = 0;

task main(){
	int irTimes[4] = {2, 1, 1.5, 1};
	int timeMoved = 0;
	int crateVal = 0;
	resetEncoders();
	initializeRobot();
	waitForStart();
	wait1Msec(delay);
	wait1Msec(500);
	moveForward(60*dir);
	ClearTimer(T1);
	StartTask(liftUp);
	for (int currentCrate = 1; currentCrate <= 4; currentCrate++){
		wait1Msec(irTimes[currentCrate-1]);
		if (SensorValue(infared) == 5){
			crateVal = currentCrate;
			brake();
			timeMoved = time1[T1];
			wait1Msec(500);
			break;
		}
	}
	if (crateVal == 1 || crateVal == 2){
		adjust12();
	}
	if (crateVal == 3 || crateVal == 4){
		adjust34();
	}

	dumpCube();
	wait1Msec(500);
	StartTask(liftDown);
	moveForward(-60*dir);
	wait1Msec(timeMoved-1000);
	brake();
	wait1Msec(500);
	turnRight(50);
	wait1Msec(turnTime);
	brake();
	wait1Msec(500);
	moveForward(60*dir);
	wait1Msec(footTime);
	brake();
	wait1Msec(500);
	turnLeft(50);
	wait1Msec(turnTime);
	brake();
	wait1Msec(500);
	moveForward(-60);
	wait1Msec(footTime*2);
	brake();

}

task liftUp(){
	motor[Lift1] = 100;
	motor[Lift2] = 100;
	wait1Msec(liftUpTime);
	motor[Lift1] = 0;
	motor[Lift2] = 0;
	EndTimeSlice();
}

task liftDown(){
	motor[Lift1] = -100;
	motor[Lift2] = -100;
	wait1Msec(liftDownTime);
	motor[Lift1] = 0;
	motor[Lift2] = 0;
	EndTimeSlice();
}



void resetEncoders(){
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;
}

void initializeRobot(){
	brake();
	motor[Lift1] = 0;
	motor[Lift2] = 0;
	motor[Sweep] = 0;
	motor[Flag] = 0;
	servo[bucket] = 135;
	servo[pin] = 0;
}

void moveForward(float power){
	currentLeft = power;
	currentRight = power;
	motor[Left] = power;
	motor[Left2] = power;
	motor[Right] = power;
	motor[Right2] = power;
}

void brake(){
	moveForward(0);
}

void adjust12(){
	moveForward(25);
	wait1Msec(adjustTime12*dir);
	brake();
}

void adjust34(){
	moveForward(-25);
	wait1Msec(adjustTime34*dir);
	brake();
}

void dumpCube(){
	int servoMovement = 40;
	wait1Msec(50);
	servo[bucket] = 135;
	wait1Msec(50);
	servo[bucket] = 135 + (dir*servoMovement);
	wait1Msec(2000);
	servo[bucket] = 135;
	wait1Msec(50);
}


void turnLeft(float power){
	currentRight = power;
	currentLeft = -power;
	motor[Right] = power;
	motor[Right2] = power;
	motor[Left] = -power;
	motor[Left2] = -power;
}

void turnRight(float power){
	currentRight = -power;
	currentLeft = power;
	motor[Right] = -power;
	motor[Right2] = -power;
	motor[Left] = power;
	motor[Left2] = power;
}



float encoderDifference(){
	float left = nMotorEncoder[Left];
	float right = nMotorEncoder[Right];
	return(abs(left-right));
}
