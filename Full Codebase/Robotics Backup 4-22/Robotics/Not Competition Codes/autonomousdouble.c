#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     infared,        sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Right,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     Lift1,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Lift2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     Sweep,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    Bucket,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

//A continuously driving autonomous IR beacon finder that has multiple attempts at finding if the block is not found the first time
//Made by Daniel Grimshaw
//Last edited on 1/7/13 at 16:28:19
//Needs some values adding at line 234

//waiting variables
bool waitForOthers = false;//boolean for waiting for anyone else to do it
unsigned short maxWait = 15000;//approximate maximum wait time

float IN = 114.649682;
float DEG = 14.35;

//vars used for driving
static float accelerationFactor;
static short orientFactor;//in moves
static short leftMotorDirectionalFactor;//in turns
static short rightMotorDirectionalFactor;//in turns
static short leftMotorSpeedCorrectionFactor;
static short rightMotorSpeedCorrectionFactor;
static short globalSpeedCorrectionFactor = 6;
static long distanceTravelled;

void correctLeft(){
	leftMotorSpeedCorrectionFactor = globalSpeedCorrectionFactor;
  rightMotorSpeedCorrectionFactor = 0;
}//correct if left is too fast

void correctRight(){
	leftMotorSpeedCorrectionFactor = 0;
  rightMotorSpeedCorrectionFactor = globalSpeedCorrectionFactor;
}//correct if right is too fast

void zeroEncoders(){
	distanceTravelled += abs((nMotorEncoder[Left] + nMotorEncoder[Right])/2);//take average for more accuracy
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;
}//zero encoders

void halt(){
	motor[Left] = 0;
	motor[Right] = 0;
	zeroEncoders();
}

void dumpCube(){
	motor[Lift1] = 100;
  motor[Lift2] = 100;
  wait1Msec(1750);
  motor[Lift1] = 0;
  motor[Lift2] = 0;
  wait10Msec(5);
  servo[Bucket] = 240;
  wait1Msec(3501);
  servo[Bucket] = 130;
  wait10Msec(100);
  motor[Lift1] = -100;
  motor[Lift2] = -100;
  wait1Msec(1250);
  motor[Lift1] = 0;
  motor[Lift2] = 0;
}//dump cube

void move(short power, float dist, bool ir){//"+" =foward  "-" =reverse for power, dist is in inches
	dist--;//might not be necessary
	orientFactor = 1;
	if (power < 0)
		orientFactor = -1;
	power = abs(power);
	dist = abs(dist*IN/3);

	zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist)//acceleration
  {
  	accelerationFactor = 30+power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor > power)
  		accelerationFactor = power;

  	if (ir == true){
  		if (SensorValue[infared] == 5){
  			dist = 0;
  			halt();
  			zeroEncoders();
  			break;}
  	}//ir

  	motor[Left] = orientFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right] = orientFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
  }//acceleration
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist)//constant speed
  {
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (ir == true){
  		if (SensorValue[infared] == 5){
  			dist = 0;
  			halt();
  			zeroEncoders();
  			break;}
  	}

  	motor[Left] = orientFactor*(power-leftMotorSpeedCorrectionFactor);
   	motor[Right] = orientFactor*(power-rightMotorSpeedCorrectionFactor);
  }
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) <dist)//deceleration
  {
  	accelerationFactor = power-power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor < 30)
  		accelerationFactor = 30;

  	if (ir == true){
  		if (SensorValue[infared] == 5){
  			dist = 0;
  			halt();
  			zeroEncoders();
  			break;}
  	}

  	motor[Left] = orientFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right] = orientFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
  }
  motor[Left] = 0;
  motor[Right] = 0;
}//move

void turn(int power, float dist){// "-" =left  "+" =right, dist is in inches
	leftMotorDirectionalFactor = 1;
	rightMotorDirectionalFactor = -1;
	if (power < 0){
		leftMotorDirectionalFactor = -1;
	  rightMotorDirectionalFactor = 1;
	}//turn left
	power = abs(power);
	dist = abs(dist*DEG/3);

	zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist){//acceleration
  	accelerationFactor = 50+power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor > power)
  		accelerationFactor = power;

  	motor[Left] = leftMotorDirectionalFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right] = rightMotorDirectionalFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
  }//acceleration
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist){//constant speed
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	motor[Left] = leftMotorDirectionalFactor*(power-leftMotorSpeedCorrectionFactor);
   	motor[Right] = rightMotorDirectionalFactor*(power-rightMotorSpeedCorrectionFactor);
  }//static speed
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist){//deceleration
  	accelerationFactor = power-power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor < 50)
  		accelerationFactor = 50;

  	motor[Left] = leftMotorDirectionalFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right] = rightMotorDirectionalFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
  }//deceleration
  motor[Left] = 0;
  motor[Right] = 0;
}//turn

task main(){
	servo[Bucket] = 130;
  unsigned short wait = 500;
  unsigned short fieldLength = 72;
  bool rep = true;
  long bucketDistance;
	unsigned short attempts = 0;
	unsigned short attemptsNumber = 3;
	long returnDistance;

	//wait for competition to begin
  waitForStart();

  if (waitForOthers == true)
  	wait1Msec(maxWait);
  while (rep == 1){//beacon search
  	attempts++;
  	move(-100, fieldLength, true);
  	wait1Msec(wait);
  	if (SensorValue[infared] == 5){
  		bucketDistance = distanceTravelled;
  		returnDistance = distanceTravelled;
  		if (bucketDistance < (30*IN)){
  			move(-50, 2, false);
  			dumpCube();
  		}//first or second buckets
  		if ((30.5*IN) < bucketDistance){
  			move(50, 2, false);
  			dumpCube();
  		}//third or fourth buckets

  		move(100, abs((returnDistance/IN)-7), false);
  		rep = false;
  	}//found bucket
  	distanceTravelled = 0;
  	if (SensorValue[infared] != 4 && SensorValue[infared] != 5 && SensorValue[infared] !=6){
  		move(100, fieldLength - 0.5, true);
  		if (SensorValue[infared] == 5){
  			bucketDistance = distanceTravelled;
  			bucketDistance = abs(bucketDistance);
  			if (bucketDistance < (27*IN)){
  				move(-50, 2, false);
  				dumpCube();
  			}//first or second buckets
  			if ((27.5*IN) < bucketDistance){
  				move(50, 2, false);
  				dumpCube();
  			}//third or fourth buckets

  			move(-100, abs(returnDistance-7), false);
  			rep = false;
  		}//found bucket
  		wait1Msec(wait);
  	}//didn't find bucket

  	if (attempts == attemptsNumber)
  		rep = false;

  	if (waitForOthers == true)
  		rep = false;

  	wait1Msec(wait);
	}//beacon search

	//we have now dumped the cube in the beacon bucket, or not found it after six runs, and returned to the starting position

  turn(100,45);//turn right 45 degrees
  wait1Msec(wait);

  move(100,20,false);//move infront of ramp
  wait1Msec(wait);

  turn(100,45);//turn right another 45 degrees
  wait1Msec(wait);

  move(100,20,false);//move to ramp
  wait1Msec(wait);

  turn(-100,90);//turn so back faces ramp
  wait1Msec(wait);

  move(-100,30,false);//go up the ramp and wait for the end
  wait1Msec(wait);
}
