#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     infared,        sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Right,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     Lift1,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Lift2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     Sweep,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

float in = 114.649682;
float deg = 16.25;

void initializeRobot()
{
	motor[Lift1] = 0;
	motor[Lift2] = 0;
	motor[Left] = 0;
	motor[Right] = 0;
	servo[bucket] = 135;
}

long i;
short currentSpeed;

void accelerate(float maxSpeed, float timeToSpeed, float startSpeed, float maxDistance)
{
	maxDistance = maxDistance*in;
	i = 0;//this will be used for the time to full speed in msec)
	currentSpeed = startSpeed;
	motor[Left] = startSpeed;
	motor[Right] = startSpeed;
	while (i < timeToSpeed){
		if ((currentSpeed + (maxSpeed/100)) >= maxSpeed){
			motor[Left] = maxSpeed-6;
			motor[Right] = maxSpeed;
			i = timeToSpeed;
		}
		if ((currentSpeed + (maxSpeed/100)) < maxSpeed){
			currentSpeed += (maxSpeed/100);
			motor[Left] = currentSpeed-6;
			motor[Right] = currentSpeed;
			wait1Msec(timeToSpeed/100);
			i += (timeToSpeed/100);
		}
		if (maxDistance <= abs(nMotorEncoder[Left]))
			i = timeToSpeed;
	}
	while (maxDistance > abs(nMotorEncoder[Left])){
		motor[Left] = maxSpeed-6;
		motor[Right] = maxSpeed;
	}
}
void decelerate(float minSpeed, float timeToSpeed, float startSpeed, float maxDistance)
{
	maxDistance = maxDistance*in;
	i = 0;//this is the time to speed as a variable
	currentSpeed = startSpeed;
	motor[Left] = startSpeed-6;
	motor[Right] = startSpeed;
	while (i < timeToSpeed){
		if ((currentSpeed - ((100 - minSpeed)/100)) >= (100 - minSpeed)){
			motor[Left] = minSpeed+6;
			motor[Right] = minSpeed;
			i = timeToSpeed;
		}
		if ((currentSpeed + ((100 - minSpeed/100))) < (100 - minSpeed)){
			currentSpeed += (100 - minSpeed);
			motor[Left] = currentSpeed+6;
			motor[Right] = currentSpeed;
			wait1Msec(timeToSpeed);
			i += (timeToSpeed/100);
		}
		if (maxDistance <= abs(nMotorEncoder[Left])){
			motor[Left] = minSpeed+6;
			motor[Right] = minSpeed;
			i = timeToSpeed;
		}
	}
	while (maxDistance > abs(nMotorEncoder[Left])){
		motor[Left] = ((startSpeed/abs(startSpeed)*40)+6);
		motor[Right] = ((startSpeed/abs(startSpeed)*40));
	}
	motor[Left] = minSpeed;
	motor[Right] = minSpeed;
}

void zeroEncoders()
{
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;
}

void dumpCube()
{
	motor[Lift1] = 100;
  motor[Lift2] = 100;

  wait1Msec(1850);

  motor[Lift1] = 0;
  motor[Lift2] = 0;

  wait10Msec(5);

  servo[bucket] = 230;

  wait1Msec(1000);

  servo[bucket] = 135;

  wait10Msec(100);

  motor[Lift1] = -100;
  motor[Lift2] = -100;

  wait1Msec(1500);

  motor[Lift1] = 0;
  motor[Lift2] = 0;
}

int ir = 0;
int wait = 500;
int speed = 100;//speed of robot while moving, changes after dump cube
int tspeed = 100;// speed of robot while turning
task main()
{
	initializeRobot();
	zeroEncoders();

  waitForStart();

  //check beacon 1
  //line up with beacon 1
  zeroEncoders();
  accelerate(-speed, 500, 0, 14);
  zeroEncoders();
  decelerate(0, 100, -speed, 4);
  wait1Msec(wait);
  //check for beacon 1
  if (SensorValue[infared] == 5)
  {
    ir = 1;//beacon is on goal 1
  }
  if (ir == 0)//check beacon 2
  {
    //line up with beacon 2
    zeroEncoders();
    accelerate(-speed, 500, 0, 7);
    zeroEncoders();
    decelerate(0, 100, -speed, 3);
    wait1Msec(wait);
    //check for beacon 2
    if (SensorValue[infared] == 5)
    {
      ir = 2;//beacon is on goal 2
    }
  }
  if (ir == 0)// check beacon 3
  {
    //line up with beacon 3
    zeroEncoders();
    accelerate(-speed, 500, 0, 16);
    zeroEncoders();
    decelerate(0, 100, -speed, 4);
    wait1Msec(wait);
    //check for beacon 3
    if (SensorValue[infared] == 5)
    {
      ir = 3;//beacon is on goal 3
    }
  }
  if (ir == 0)//check beacon 4
  {
    //line up with beacon 4
    zeroEncoders();
    accelerate(-speed, 500, 0, 7);
    zeroEncoders();
    decelerate(0, 100,  -speed, 3);
    wait1Msec(wait);
    //check for beacon 4
    if (SensorValue[infared] == 5)
    {
      ir = 4;//beacon is on goal 4
    }
  }

  //align with goal
  //goal 3 and 4 are already aligned
  if (ir == 1 || ir == 2)//align 1 or 2
  {
  	zeroEncoders();
    accelerate(-speed, 100, 0, 1.5);
    zeroEncoders();
    decelerate(0, 50, -speed, 0.5);
    wait1Msec(wait);
  }
  if (ir == 0)//if ir was not found, align with goal 1
  {
    zeroEncoders();
    accelerate(speed, 500, 0, 35);
    zeroEncoders();
    decelerate(0, 250, speed, 4);
    wait1Msec(wait);
  }

  dumpCube();

  speed=100;

  //back up, center 18in away from end of pendulum, starting side
  if (ir == 0 || ir == 1)
  {
    zeroEncoders();
    accelerate(speed, 500, 0, 19);
    zeroEncoders();
    decelerate(0, 100, speed, 3.5);
    wait1Msec(wait);
  }
  if (ir == 2)
  {
    zeroEncoders();
    accelerate(speed, 500, 0, 29);
    zeroEncoders();
    decelerate(0, 100, speed, 3.5);
    wait1Msec(wait);
  }
  if (ir == 3)
  {
    zeroEncoders();
    accelerate(speed, 750, 0, 48) ;
    zeroEncoders();
    decelerate(0, 100, speed, 3.5);
    wait1Msec(wait);
  }
  if (ir == 4)
  {
    zeroEncoders();
    accelerate(speed, 1000, 0, 58);
    zeroEncoders();
    decelerate(0, 100, speed, 3.5);
    wait1Msec(wait);
  }

  //turn right 90deg
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) < 90*deg)
  {
    motor[Left] = -tspeed;
    motor[Right] = tspeed;
  }
  motor[Left] = 0;
  motor[Right] = 0;
  wait1Msec(wait);

  //move infront of ramp
  zeroEncoders();
  accelerate(-speed, 500, 0, 28);
  zeroEncoders();
	decelerate(0, 150, -speed, 4);
  wait1Msec(wait);

  //turn so back faces ramp
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) < 90*deg)
  {
    motor[Left] = -tspeed;
    motor[Right] = tspeed;
  }
  motor[Left] = 0;
  motor[Right] = 0;
  wait1Msec(wait);

  //drive up ramp
  zeroEncoders();
  accelerate(-speed, 500, 0, 34);
  zeroEncoders();
  decelerate(0, 250, -speed, 3);
  wait1Msec(wait);
}
