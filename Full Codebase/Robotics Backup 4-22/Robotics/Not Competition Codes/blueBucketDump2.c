#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     infared,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touch,          sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Right,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     Left2,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     Right2,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     Lift1,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Lift2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     Sweep,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    pin,                  tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

//A continuously driving autonomous IR beacon finder that has multiple attempts at finding if the block is not found the first time
//Made by Daniel Grimshaw
//Last edited on 1/7/13 at 16:28:19
//Needs some values adding at line 234

//waiting variables
bool waitForOthers = false;//boolean for waiting for anyone else to do it
unsigned short maxWait = 5000;//approximate maximum wait time

float IN = 114.649682;
float DEG = 14.35;

//vars used for driving
static float accelerationFactor;
static short orientFactor;//in moves
static short leftMotorDirectionalFactor;//in turns
static short rightMotorDirectionalFactor;//in turns
static short leftMotorSpeedCorrectionFactor;
static short rightMotorSpeedCorrectionFactor;
static short globalSpeedCorrectionFactor = 6;
static long  distanceTravelled;
static short RAISELIFTTIME = 1650;

void initializeRobot(){
	servo[bucket] = 135;
	servo[pin] = 0;
}

void correctLeft(){
	leftMotorSpeedCorrectionFactor = globalSpeedCorrectionFactor;
  rightMotorSpeedCorrectionFactor = 0;
}//correct if left is too fast

void correctRight(){
	leftMotorSpeedCorrectionFactor = 0;
  rightMotorSpeedCorrectionFactor = globalSpeedCorrectionFactor;
}//correct if right is too fast

void zeroEncoders(){
	distanceTravelled += abs((nMotorEncoder[Left] + nMotorEncoder[Right])/2);//take average for more accuracy
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;
}//zero encoders

void halt(){
	motor[Left] = 0;
	motor[Right] = 0;
	zeroEncoders();
}

void dumpCube(){
  servo[bucket] = 15;
  wait1Msec(2501);
  servo[bucket] = 130;
  wait10Msec(100);
}//dump cube

void move(short power, float dist, bool ir, bool raiseLift){//"+" =foward  "-" =reverse for power, dist is in inches
	dist--;//might not be necessary
	orientFactor = 1;
	if (power < 0)
		orientFactor = -1;
	power = abs(power);
	dist = abs(dist*IN/3);
	if (raiseLift){
		ClearTimer(T1);
		motor[Lift1] = 100;
		motor[Lift2] = 100;
	}
	if (!raiseLift){
		ClearTimer(T1);
		motor[Lift1] = -100;
		motor[Lift2] = -100;
	}

	zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist)//acceleration
  {
  	accelerationFactor = 30+power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor > power)
  		accelerationFactor = power;

  	if (ir == true){
  		if (SensorValue[infared] == 5){
  			dist = 0;
  			halt();
  			zeroEncoders();
  			break;}
  	}//ir
  	if (raiseLift){
  		if (time1[T1] >= RAISELIFTTIME){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}
  	}//raising lift
  	if (!SensorValue[touch]){
  		motor[Lift1] = 0;
  		motor[Lift2] = 0;
  	}//bottom of lift

  	motor[Left] = orientFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right] = orientFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
  }//acceleration
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist)//constant speed
  {
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (ir == true){
  		if (SensorValue[infared] == 5){
  			dist = 0;
  			halt();
  			zeroEncoders();
  			break;}
  	}
  	if (raiseLift){
  		if (time1[T1] >= RAISELIFTTIME){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}
  	}
  	if (!SensorValue[touch]){
  		motor[Lift1] = 0;
  		motor[Lift2] = 0;
  	}//bottom of lift

  	motor[Left] = orientFactor*(power-leftMotorSpeedCorrectionFactor);
   	motor[Right] = orientFactor*(power-rightMotorSpeedCorrectionFactor);
  }
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) <dist)//deceleration
  {
  	accelerationFactor = power-power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor < 5)
  		accelerationFactor = 5;

  	if (ir == true){
  		if (SensorValue[infared] == 5){
  			dist = 0;
  			halt();
  			zeroEncoders();
  			break;}
  	}
  	if (raiseLift){
  		if (time1[T1] >= RAISELIFTTIME){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}
  	}
  	if (!SensorValue[touch]){
  		motor[Lift1] = 0;
  		motor[Lift2] = 0;
  	}//bottom of lift

  	motor[Left] = orientFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right] = orientFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
  }
  motor[Left] = 0;
  motor[Right] = 0;
}//move

void turn(int power, float dist){// "-" =left  "+" =right, dist is in inches
	leftMotorDirectionalFactor = 1;
	rightMotorDirectionalFactor = -1;
	if (power < 0){
		leftMotorDirectionalFactor = -1;
	  rightMotorDirectionalFactor = 1;
	}//turn left
	power = abs(power);
	dist = abs(dist*DEG/3);

	zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist){//acceleration
  	accelerationFactor = 50+power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor > power)
  		accelerationFactor = power;

  	motor[Left] = leftMotorDirectionalFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right] = rightMotorDirectionalFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
  }//acceleration
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist){//constant speed
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	motor[Left] = leftMotorDirectionalFactor*(power-leftMotorSpeedCorrectionFactor);
   	motor[Right] = rightMotorDirectionalFactor*(power-rightMotorSpeedCorrectionFactor);
  }//static speed
  zeroEncoders();
  while(abs(nMotorEncoder[Left]) < dist){//deceleration
  	accelerationFactor = power-power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor < 50)
  		accelerationFactor = 50;

  	motor[Left] = leftMotorDirectionalFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
   	motor[Right] = rightMotorDirectionalFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
  }//deceleration
  motor[Left] = 0;
  motor[Right] = 0;
}//turn

task main()
{
	initializeRobot();
	short wait = 75;
	waitForStart();

	if (waitForOthers)
		wait1Msec(maxWait);

	move(-100, 17, true, true);
	if (time1[T1] >= RAISELIFTTIME){
		motor[Lift1] = 0;
		motor[Lift1] = 0;
	}
	wait1Msec(wait);

	dumpCube();

	wait1Msec(wait);

	move(100, 11.5, false, false);

	if (!SensorValue[touch]){
		motor[Lift1] = 0;
		motor[Lift2] = 0;
	}

	turn(100,45);//turn right 90deg
  wait1Msec(wait);

  move(100,20, false, false);//move infront of ramp
  wait1Msec(wait);

  turn(100,45);//turn so back faces ramp
  wait1Msec(wait);

  move(100,20, false, false);//move to ramp
  wait1Msec(wait);

  turn(-100,90);//turn to ramp
  wait1Msec(wait);

  move(-100,40, false, false);//go up the ramp
  wait1Msec(wait);
}
