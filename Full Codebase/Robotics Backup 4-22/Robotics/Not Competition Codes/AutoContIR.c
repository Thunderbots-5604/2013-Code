#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     infared,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touch,          sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Right,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     Left2,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     Right2,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     Lift1,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Lift2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     Sweep,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    pin,                  tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/* the above code was actually written by Daniel too, not the configuration wizard */

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

//A continuously driving autonomous IR beacon finder that has multiple attempts at finding if the block is not found the first time
//Made (almost entirely) by Daniel Grimshaw
//Last edited on 1/25/14 at 21:46:29

//waiting variables
const bool waitForOthers = false;//boolean for waiting for anyone else to do it
unsigned const short maxWait = 5000;//approximate maximum wait time

const float IN = 114.649682;
const float DEG = 14.35;

//vars used for driving
static float accelerationFactor;
static short orientFactor;//in moves
static short leftMotorDirectionalFactor;//in turns
static short rightMotorDirectionalFactor;//in turns
static short leftMotorSpeedCorrectionFactor;
static short rightMotorSpeedCorrectionFactor;
const static short globalSpeedCorrectionFactor = 10;
static long distanceTravelled;
const static short RAISELIFTTIME = 1600;
static long moving = 0;
static long movingBackup = 0;
static bool leftStuck = false;
static bool rightStuck = false;
const static short checkTime = 3000;
const static unsigned short checkDistance = 100;

void initializeRobot(){
	servo[bucket] = 135;
	servo[pin] = 0;
}

void correctLeft(){
	leftMotorSpeedCorrectionFactor = globalSpeedCorrectionFactor;
  rightMotorSpeedCorrectionFactor = 0;
}//correct if left is too fast

void correctRight(){
	leftMotorSpeedCorrectionFactor = 0;
  rightMotorSpeedCorrectionFactor = globalSpeedCorrectionFactor;
}//correct if right is too fast

void zeroEncoders(){
	distanceTravelled += abs((nMotorEncoder[Left] + nMotorEncoder[Right])/2);//take average for more accuracy
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;
}//zero encoders

void halt(){
	motor[Left] = 0;
	motor[Right] = 0;
	zeroEncoders();
}

void dumpCube(){
	motor[Lift1] = 100;
  motor[Lift2] = 100;
  wait1Msec(1750);
  motor[Lift1] = 0;
  motor[Lift2] = 0;
  wait10Msec(5);
  servo[bucket] = 240;
  wait1Msec(2501);
  servo[bucket] = 130;
  wait10Msec(100);
  motor[Lift1] = -100;
  motor[Lift2] = -100;
  wait1Msec(1250);
  motor[Lift1] = 0;
  motor[Lift2] = 0;
}//dump cube

void move(short power, float dist, bool ir, bool raiseLift){//"+" =foward  "-" =reverse for power, dist is in inches
	dist--;//might not be necessary
	orientFactor = 1;
	zeroEncoders();
	if (power < 0)
		orientFactor = -1;
	power = abs(power);
	dist = abs(dist*IN/3);
	if (raiseLift){
		ClearTimer(T1);
		motor[Lift1] = 100;
		motor[Lift2] = 100;
	}
	if (!raiseLift){
		ClearTimer(T1);
		motor[Lift1] = -100;
		motor[Lift2] = -100;
	}
	ClearTimer(T2);
	moving = abs(nMotorEncoder[Left]);
	movingBackup = abs(nMotorEncoder[Right]);

  while(abs(nMotorEncoder[Left]) < dist)//acceleration
  {
  	accelerationFactor = 30+power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor > power)
  		accelerationFactor = power;

  	if (ir == true){
  		if (SensorValue[infared] == 4){
  			dist = 0;
  			halt();
  			zeroEncoders();
  			break;}
  	}//ir
  	if (raiseLift){
  		if (time1[T1] >= RAISELIFTTIME){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}
  	}//raising lift
  	if (!raiseLift){
  		if (SensorValue[touch]){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}//bottom of lift
  	}

  	if (time1[T2] >= checkTime){
  		if (moving+checkDistance > abs(nMotorEncoder[Left])){
  			motor[Left] = 0;
  			motor[Left2] = 0;
  			leftStuck = true;
  		}//left is stuck
  		if (movingBackup+checkDistance > abs(nMotorEncoder[Right])){
  			motor[Right] = 0;
  			motor[Right2] = 0;
  			rightStuck = true;
  		}//right is stuck
  		moving = abs(nMotorEncoder[Left]);
			movingBackup = abs(nMotorEncoder[Right]);
			ClearTimer(T2);
		}//safety catch

		if (!leftStuck){
  		motor[Left] = orientFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
  		motor[Left2] = orientFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
  	}//change left speed
  	if (!rightStuck){
   		motor[Right] = orientFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
   		motor[Right2] = orientFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
   	}//change right speed
  }//acceleration
  zeroEncoders();
  moving = abs(nMotorEncoder[Left]);
	movingBackup = abs(nMotorEncoder[Right]);
	ClearTimer(T2);

  while(abs(nMotorEncoder[Left]) < dist)//constant speed
  {
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (ir == true){
  		if (SensorValue[infared] == 4){
  			dist = 0;
  			halt();
  			zeroEncoders();
  			break;}
  	}
  	if (raiseLift){
  		if (time1[T1] >= RAISELIFTTIME){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}
  	}
  	if (!raiseLift){
  		if (SensorValue[touch]){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}//bottom of lift
  	}

  	if (time1[T2] >= checkTime){
  		if (moving+checkDistance > abs(nMotorEncoder[Left])){
  			motor[Left] = 0;
  			motor[Left2] = 0;
  			leftStuck = true;
  		}//left is stuck
  		if (movingBackup+checkDistance > abs(nMotorEncoder[Right])){
  			motor[Right] = 0;
  			motor[Right2] = 0;
  			rightStuck = true;
  		}//right is stuck
  		moving = abs(nMotorEncoder[Left]);
			movingBackup = abs(nMotorEncoder[Right]);
			ClearTimer(T2);
		}//safety catch

		if (!leftStuck){
  		motor[Left] = orientFactor*(power-leftMotorSpeedCorrectionFactor);
  		motor[Left2] = orientFactor*(power-leftMotorSpeedCorrectionFactor);
  	}
  	if (!rightStuck){
   		motor[Right] = orientFactor*(power-rightMotorSpeedCorrectionFactor);
   		motor[Right2] = orientFactor*(power-rightMotorSpeedCorrectionFactor);
   	}
  }//const speed
  zeroEncoders();
  moving = abs(nMotorEncoder[Left]);
	movingBackup = abs(nMotorEncoder[Right]);
	ClearTimer(T2);

  while(abs(nMotorEncoder[Left]) <dist)//deceleration
  {
  	accelerationFactor = power-power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor < 1)
  		accelerationFactor = 1;

  	if (ir == true){
  		if (SensorValue[infared] == 4){
  			dist = 0;
  			halt();
  			zeroEncoders();
  			break;}
  	}
  	if (raiseLift){
  		if (time1[T1] >= RAISELIFTTIME){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}
  	}
  	if (!raiseLift){
  		if (SensorValue[touch]){
  			motor[Lift1] = 0;
  			motor[Lift2] = 0;
  		}//bottom of lift
  	}

  	if (time1[T2] >= checkTime){
  		if (moving+checkDistance > abs(nMotorEncoder[Left])){
  			motor[Left] = 0;
  			motor[Left2] = 0;
  			leftStuck = true;
  		}//left is stuck
  		if (movingBackup+checkDistance > abs(nMotorEncoder[Right])){
  			motor[Right] = 0;
  			motor[Right2] = 0;
  			rightStuck = true;
  		}//right is stuck
  		moving = abs(nMotorEncoder[Left]);
			movingBackup = abs(nMotorEncoder[Right]);
			ClearTimer(T2);
		}//safety catch

		if (!leftStuck){
  		motor[Left] = orientFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
  		motor[Left2] = orientFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
  	}
  	if (!rightStuck){
   		motor[Right] = orientFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
   		motor[Right2] = orientFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
  	}
  }//decel
  motor[Left] = 0;
  motor[Right] = 0;
  motor[Left2] = 0;
  motor[Right2] = 0;
}//move

void turn(int power, float dist){// "-" =left  "+" =right, dist is in inches
	leftMotorDirectionalFactor = 1;
	rightMotorDirectionalFactor = -1;
	if (power < 0){
		leftMotorDirectionalFactor = -1;
	  rightMotorDirectionalFactor = 1;
	}//turn left
	power = abs(power);
	dist = abs(dist*DEG/3);
	zeroEncoders();
	ClearTimer(T2);
	moving = abs(nMotorEncoder[Left]);
	movingBackup = abs(nMotorEncoder[Right]);

  while(abs(nMotorEncoder[Left]) < dist){//acceleration
  	accelerationFactor = 50+power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor > power)
  		accelerationFactor = power;

  	if (time1[T2] >= checkTime){
  		if (moving+checkDistance > abs(nMotorEncoder[Left])){
  			motor[Left] = 0;
  			motor[Left2] = 0;
  			leftStuck = true;
  		}//left is stuck
  		if (movingBackup+checkDistance > abs(nMotorEncoder[Right])){
  			motor[Right] = 0;
  			motor[Right2] = 0;
  			rightStuck = true;
  		}//right is stuck
  		moving = abs(nMotorEncoder[Left]);
			movingBackup = abs(nMotorEncoder[Right]);
			ClearTimer(T2);
		}//safety catch

		if (!leftStuck){
  		motor[Left] = leftMotorDirectionalFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
  		motor[Left2] = leftMotorDirectionalFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
  	}
  	if (!rightStuck){
   		motor[Right] = rightMotorDirectionalFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
   		motor[Right2] = rightMotorDirectionalFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
   	}
  }//acceleration
  zeroEncoders();
  ClearTimer(T2);
	moving = abs(nMotorEncoder[Left]);
	movingBackup = abs(nMotorEncoder[Right]);

  while(abs(nMotorEncoder[Left]) < dist){//constant speed
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (time1[T2] >= checkTime){
  		if (moving+checkDistance > abs(nMotorEncoder[Left])){
  			motor[Left] = 0;
  			motor[Left2] = 0;
  			leftStuck = true;
  		}//left is stuck
  		if (movingBackup+checkDistance > abs(nMotorEncoder[Right])){
  			motor[Right] = 0;
  			motor[Right2] = 0;
  			rightStuck = true;
  		}//right is stuck
  		moving = abs(nMotorEncoder[Left]);
			movingBackup = abs(nMotorEncoder[Right]);
			ClearTimer(T2);
		}//safety catch

		if (!leftStuck){
  		motor[Left] = leftMotorDirectionalFactor*(power-leftMotorSpeedCorrectionFactor);
  		motor[Left2] = leftMotorDirectionalFactor*(power-leftMotorSpeedCorrectionFactor);
  	}
  	if (!rightStuck){
   		motor[Right] = rightMotorDirectionalFactor*(power-rightMotorSpeedCorrectionFactor);
   		motor[Right2] = rightMotorDirectionalFactor*(power-rightMotorSpeedCorrectionFactor);
   	}
  }//static speed
  zeroEncoders();
  ClearTimer(T2);
	moving = abs(nMotorEncoder[Left]);
	movingBackup = abs(nMotorEncoder[Right]);

  while(abs(nMotorEncoder[Left]) < dist){//deceleration
  	accelerationFactor = power-power*(abs(nMotorEncoder[Left])/dist);
  	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  		correctLeft();
  	if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  		correctRight();

  	if (accelerationFactor < 50)
  		accelerationFactor = 50;

  	if (time1[T2] >= checkTime){
  		if (moving+checkDistance > abs(nMotorEncoder[Left])){
  			motor[Left] = 0;
  			motor[Left2] = 0;
  			leftStuck = true;
  		}//left is stuck
  		if (movingBackup+checkDistance > abs(nMotorEncoder[Right])){
  			motor[Right] = 0;
  			motor[Right2] = 0;
  			rightStuck = true;
  		}//right is stuck
  		moving = abs(nMotorEncoder[Left]);
			movingBackup = abs(nMotorEncoder[Right]);
			ClearTimer(T2);
		}//safety catch

		if (!leftStuck){
  		motor[Left] = leftMotorDirectionalFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
  		motor[Left2] = leftMotorDirectionalFactor*(accelerationFactor-leftMotorSpeedCorrectionFactor);
  	}
  	if (!rightStuck){
   		motor[Right] = rightMotorDirectionalFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
   		motor[Right2] = rightMotorDirectionalFactor*(accelerationFactor-rightMotorSpeedCorrectionFactor);
   	}
  }//deceleration
  motor[Left] = 0;
  motor[Left2] = 0;
  motor[Right] = 0;
  motor[Right2] = 0;
}//turn

task main(){
	initializeRobot();
  unsigned short wait = 75;
  unsigned short fieldLength = 70;
  bool rep = true;
  long bucketDistance;
	unsigned short attempts = 0;
	unsigned short attemptsNumber = 1;
	bool foundBucket = false;

	//wait for competition to begin
  waitForStart();

  if (waitForOthers == true)
  	wait1Msec(maxWait);
  while (rep == 1){//beacon search
  	attempts++;
  	move(-100, fieldLength, true, false);
  	wait1Msec(wait);
  	if (SensorValue[infared] == 4 || SensorValue[infared] == 5){
  		bucketDistance = distanceTravelled;
  		foundBucket = true;
  		if (bucketDistance < 28*IN){
  			//move(-50, 5, false, false);
  			dumpCube();
  		}//first or second buckets
  		if (30.5*IN < bucketDistance){
  			//move(-50, 5, false, false);
  			dumpCube();
  		}//third or fourth buckets

  		while (nMotorEncoder[Left] < -5.5*IN){
  			motor[Left] = 100 - leftMotorSpeedCorrectionFactor;
  			motor[Left2] = 100 - leftMotorSpeedCorrectionFactor;
  			motor[Right] = 100 - rightMotorSpeedCorrectionFactor;
  			motor[Right2] = 100 - rightMotorSpeedCorrectionFactor;
  			if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  				correctLeft();
  			if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  				correctRight();
  		}
  		//move(100, 7, false)
  		rep = false;
  	}//found bucket
  	distanceTravelled = 0;
  	if (SensorValue[infared] != 4 && SensorValue[infared] != 5 && SensorValue[infared] !=3 && SensorValue[infared] != 6){
  		move(100, fieldLength - 0.5, true, false);
  		if (SensorValue[infared] == 5 || SensorValue[infared] == 4){
  			bucketDistance = distanceTravelled;
  			foundBucket = true;
  			//returnDistance = distanceTravelled;
  			if (bucketDistance < (25*IN)){
  				//move(-50, 2, false, false);
  				dumpCube();
  			}//first or second buckets
  			if ((27.5*IN) < bucketDistance){
  				//move(50, 2, false, false);
  				dumpCube();
  			}//third or fourth buckets

  			while (nMotorEncoder[Left] < -5.5*IN){
  				motor[Left] = -100 + leftMotorSpeedCorrectionFactor;
  				motor[Left2] = -100 + leftMotorSpeedCorrectionFactor;
  				motor[Right] = -100 + rightMotorSpeedCorrectionFactor;
  				motor[Right2] = -100 + rightMotorSpeedCorrectionFactor;
  				if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  					correctLeft();
  				if (abs(nMotorEncoder[Left]) < abs(nMotorEncoder[Right]))
  					correctRight();
  			}
  			rep = false;
  		}//found bucket
  		wait1Msec(wait);
  	}//didn't find bucket

  	if (attempts == attemptsNumber)
  		rep = false;

  	if (waitForOthers == true)
  		rep = false;

  	wait1Msec(wait);
	}//beacon search

	if (!foundBucket){
		move(-50, 17, true, true);
		servo[bucket] = 240;
  	wait1Msec(2501);
  	servo[bucket] = 130;
		move(50, 12.5, false, true);
	}

	//we have now dumped the cube in the beacon bucket, or not found it after six runs, and returned to the starting position

  turn(100,45);//turn right 45 degrees
  wait1Msec(wait);

  move(100,20,false, false);//move infront of ramp
  wait1Msec(wait);

  turn(100,45);//turn right another 45 degrees
  wait1Msec(wait);

  move(100,20,false, false);//move to ramp
  wait1Msec(wait);

  turn(-100,90);//turn so back faces ramp
  wait1Msec(wait);

  move(-100,30,false, false);//go up the ramp and wait for the end
  wait1Msec(wait);
}
