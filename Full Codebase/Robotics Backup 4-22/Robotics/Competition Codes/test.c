#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     infrared,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touch,          sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Right,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     Lift1,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Lift2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     Left2,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     Right2,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     Sweep,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    pin,                  tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
///////////******UNCOMMENT THE TASK LINES************365,367,369,280,281,292,293
//version 6.0.1 alpha

#include "JoystickDriver.c"

//Do not touch this next twelve lines of code, they are easy to mess up
#ifndef NXTBUTTONPRESS
#define NXTBUTTONPRESS 325
#endif
#ifndef PI
#define PI 3.14159265358979323846246
#endif
//#ifndef TURN90TIME
static const int TURN90TIME = 535;
//#endif
//#ifndef TURN45TIME
static const int TURN45TIME = 350;
//#endif

bool testing = false;

//Up ramp time
static const int UPRAMPTIME = 2000;
static const int UPRAMPDIST = 27;
//static const short delay = 0;//set this number to the delay in seconds ***(SET IN GUI (DANIEL))***

//initializing all procedures that are used (***(Actually called prototyping, not initializing (Daniel))***)
static void resetEncoders();
static void initializeRobot();
static void move(int speed);
static void moveForward(float power);
static void dumpCube();
static void turn(float power); //right is positive, left is negative
static void turn90(bool right);//true is right, false is left
static void turn45(bool right);//true is right, false is left
static void newturn45(bool right);
static void swingLeft(bool forward);//true is forward, false is backward

void brake(int waitTime = 0){
	ClearTimer(T3);
	move(0);
	while (time1[T3] <= waitTime*1000)
		nxtDisplayCenteredTextLine(0, "%d", SensorValue[infrared]);

}

void pauseForTest(){
	brake();
	while (!nNxtButtonPressed == 3){
		wait1Msec(10);
	}
}

//initializing all functions that are used ***Prototyping, not initializing (Daniel)***
static float distanceTravelled();
static float encoderDifference();

//for the move function
int adjust = 20;
int dir;
int leftadjust;
int rightadjust;

//initializing all tasks that are used ***Prototyping, for the third time (Daniel)***
task liftUp();
task liftDown();

//initializing all the global integers that are used ***this is initializing (Daniel)***
static const unsigned short liftUpTime = 2050;
static const unsigned short liftDownTime = 1300;
static const short swingTime = 890;
static short power;
static const unsigned short rampLineUpDistance = 25;

//initializing all the global floats that are used
static const float in = 360/PI;
static float distToBucket;

//initializing all the global booleans that are used
bool liftedUp = false;
bool foundCrate = false;
bool liftIsDown = false;

//initializing all the arrays that are used
static const float irDistances[4] = {16.5, 10, 18.5, 9}; //do not change this list without updating irBackDistances[]
//static const float irBackDistances[4] = {irDistances[0]-7, irBackDistances[0]+irDistances[1], irBackDistances[1]+irDistances[2], irBackDistances[2]+irDistances[3]}; //***five inches off of the TOTAL DISTANCE TRAVELLED, !!!NOT TWO INCHES LESS THAN irDistances!!! (Daniel)***
// The line above this is replaced by the line below this comment, and the assignments are replaced by a for loop inside the task main
static float irBackDistances[4] = {irDistances[0]-7,-4,0,-2};
static const short irValues[4] = {5, 5, 4, 4};

static short crateVal = 0;//initializes the value that will be set to the crate which has the IR beacon

task main(){
	waitForStart();
	resetEncoders();
	ClearTimer(T1);
	while (nMotorEncoder[Left] <= 1000){
		motor[Left] = 50;
		motor[Left2] = 50;
	}
	brake();
	ClearTimer(T1);
	while(time1[T1]<10000){
		nxtDisplayCenteredTextLine(0, "%d", nMotorEncoder[Left]);
		nxtDisplayCenteredTextLine(1, "%d", nMotorEncoder[Right]);
	}
	ClearTimer(T1);

	while (nMotorEncoder[Right] <= 1000){
		motor[Right] = 50;
		motor[Right2] = 50;
	}
	brake();
	ClearTimer(T1);
	while(time1[T1]<10000){
		nxtDisplayCenteredTextLine(0, "%d", nMotorEncoder[Left]);
		nxtDisplayCenteredTextLine(1, "%d", nMotorEncoder[Right]);
	}
	wait1Msec(2000);
	while(time1[T1]<50000){
		nxtDisplayCenteredTextLine(0, "%d", nMotorEncoder[Left]);
		nxtDisplayCenteredTextLine(1, "%d", nMotorEncoder[Right]);
	}


}

task liftUp(){
	//motor[Lift1] = 100;
	//motor[Lift2] = 100;
	wait1Msec(liftUpTime);

	motor[Lift1] = 0;
	motor[Lift2] = 0;
	liftedUp = true;

	EndTimeSlice();
}

task liftDown(){
	//motor[Lift1] = -100;
	//motor[Lift2] = -100;
	wait1Msec(liftDownTime);

	motor[Lift1] = 0;
	motor[Lift2] = 0;
	liftIsDown = true;

	EndTimeSlice();
}

void resetEncoders(){
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;
}

void initializeRobot(){
	resetEncoders();
	brake();
	motor[Lift1] = 0;
	motor[Lift2] = 0;
	motor[Sweep] = 0;
	motor[Flag] = 0;
	servo[bucket] = 72;
	servo[pin] = 0;
}

void move(int speed)
{
	dir = 1;
	if (speed < 0)
		dir = -1;
	if (speed == 0)
		dir = 0;
  speed = abs(speed);
	if (abs(nMotorEncoder[Left]) > abs(nMotorEncoder[Right]))
  {
  	leftadjust = adjust;
  	rightadjust = 0;
  }
  else
  {
  	leftadjust = 0;
  	rightadjust = adjust;
  }
  motor[Left] = dir*(speed-leftadjust);
  motor[Left2] = dir*(speed-leftadjust);
  motor[Right] = dir*(speed-rightadjust);
  motor[Right2] = dir*(speed-rightadjust);
}

void moveForward(float power){
	motor[Left] = power;
	motor[Left2] = power;
	motor[Right] = power;
	motor[Right2] = power;
}

void adjust12(){
	moveForward(25);
	while (distanceTravelled() <= 2){}
	brake();
}

void adjust34(){
	moveForward(-25);
	while (distanceTravelled() <= 2){}
	brake();
}

void dumpCube(){
	int servoMovement = 40;
	wait1Msec(50);
	//servo[bucket] = 72;
	wait1Msec(50);
	//servo[bucket] = 72 + (servoMovement);
	wait1Msec(2000);
	//servo[bucket] = 72;
	wait1Msec(50);
}

void turn(float power){ //right is positive, left is negative
	motor[Left] = power;
	motor[Left2] = power;
	motor[Right] = -power;
	motor[Right2] = -power;
}

void turn90(bool right){ //true is right, false is left
	/*
	if (right)
		power = 100;
	if (!right)
		power = -100;
	motor[Left] = power;
	motor[Left2] = power;
	motor[Right] = -power;
	motor[Right2] = -power;
	wait1Msec(TURN90TIME);
	brake();
	*/
	turn45(right);
	turn45(right);
}

/*void turn45(bool right){ //true is right, false is left
	if (right)
		power = 100;
	if (!right)
		power = -100;
	motor[Left] = power;
	motor[Left2] = power;
	motor[Right] = -power;
	motor[Right2] = -power;
	wait1Msec(TURN45TIME);
	brake();
}*/

//***************************WILL ONLY WORK FOR RIGHT TURNS**********************************
void turn45(bool right){ //true is right, false is left
	if (right){
		power = 100;
	}
	else{
		power = -100;
	}
	resetEncoders();
	motor[Left] = power;
	motor[Left2] = power;
	motor[Right] = -power;
	motor[Right2] = -power;
	//wait1Msec(TURN45TIME);
	while ((abs(nMotorEncoder[Left]) + abs(nMotorEncoder[Right]))/2 < 645)
		wait1Msec(1);
	brake();
}

float turn45Num(){
	return ((abs(nMotorEncoder[Left]-885)+abs(nMotorEncoder[Right]+447))/2);
}

void newturn45(bool right){
	if (right)
		power = 100;
	if (!right)
		power = -100;
	motor[Left] = power;
	motor[Left2] = power;
	motor[Right] = -power;
	motor[Right2] = -power;
	while (turn45Num() <= 10){
		wait1Msec(1);
	}
	brake();
}
void swingLeft(bool forward){
	short direction = 1;
	if (!forward)
		direction = -1;
	motor[Left] = 100*direction;
	motor[Left2] = 100*direction;
}

float distanceTravelled(){
	return((abs(nMotorEncoder[Left]+nMotorEncoder[Right])/2)/in);
}

float encoderDifference(){
	float left = nMotorEncoder[Left];
	float right = nMotorEncoder[Right];
	return(abs(left-right));
}
