#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     infrared,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touch,          sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Right,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     Lift1,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Lift2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     Left2,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     Right2,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     Sweep,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    pin,                  tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//version 6.0.1 alpha

#include "JoystickDriver.c"
#include "autoIncludes.h"

task main(){

	for(int i = 1; i <= 3; i++)
	{
		irBackDistances[i] += irDistances + irBackDistances[i-1];
	}

	//This is for the nxt GUI
  nNxtExitClicks = 3;
  static int delay = 0;
  static int i;
  resetEncoders();

  StartTask(waitUntilStart);

  //This next section of code is a nxt delay setting gui, please do not mess this up, also...
  ///***********************PRESS THE ORANGE BUTTON!!!!**********************
  while (nNxtButtonPressed != 3 && !matchHasStarted){
  	if (nNxtButtonPressed == 1)
  		delay += 1;
  	if (nNxtButtonPressed == 2)
  		delay -= 1;
  	/*
  	if (delay > 15)
  		delay = 0;
  	if (delay < 0)
  		delay = 15;
  		*/
  	if (nNxtButtonPressed == 0)
  	{
  		if (delay != 0)
  			i = 0;
  		else
  			i = 15;
  		delay = i;
  	}

  	nxtDisplayCenteredTextLine(0, "%2.2f second delay", delay);
  	wait1Msec(NXTBUTTONPRESS);

  }
  eraseDisplay();
  resetEncoders();
  StartTask(nxtDebugger);
  resetEncoders();

  while (!matchHasStarted){wait1Msec(1);}

	resetEncoders();//sets the wheel encoders to zero
	initializeRobot();//initializes the robot

	ClearTimer(T1);//Used for the countering pushes at the en3d

	wait1Msec(delay*1000);//waits the number of seconds set by the program

	move(-50);//starts moving backwards

	StartTask(liftUp);//start moving the lift up while the program runs

	for (short currentCrate = 0; currentCrate < 4; currentCrate++){//runs through the next block four times or until it finds the beacon
		while (distanceTravelled() <= irDistances[currentCrate]-1){move(-50);}//waits unti?l the robot is at each bucket
		if (testing)
			brake(5);
		if (currentCrate == 2)
			brake(2);
		for (short i=0; i<10; i++){
			if (currentCrate == 2){
				if (SensorValue[infrared] == 5 || SensorValue[infrared] == irValues[1]){
					foundCrate = true;
					crateVal = currentCrate+1;//sets the global variable that shows the rest of the program where the beacon is
					brake();//stops the robot
					wait1Msec(250);//slight delay (to lose momentum and completely stop)
					distToBucket = distanceTravelled();
					currentCrate = 4;
					i = 10;
				}
			}
			if (SensorValue(infrared) == irValues[currentCrate]){//checks to see if the robot is at the bucket with the beacon
				foundCrate = true;
				crateVal = currentCrate+1;//sets the global variable that shows the rest of the program where the beacon is
				brake();//stops the robot
				wait1Msec(250);//slight delay (to lose momentum and completely stop)
				distToBucket = distanceTravelled();
				currentCrate = 4;
				i = 10;
				continue;

			}
			wait10Msec(1);
		}
		if (crateVal != 0){
			currentCrate = 4;
			continue;
		}
		resetEncoders();//resets the encoders after every basket
	}

	resetEncoders();//resets the encoders again (to confirm that they were reset when the for loop broke)
	brake();//stops the robot in case the first one didn't work

	if (!foundCrate || crateVal == 0)//runs through if the sensor did not find the beacon
		crateVal = 4;//the robot is at the fourth bucket if it did not find the beacon anywhere else

	while (!liftedUp){}//waits if the lift is not all the way up yet
	StopTask(liftUp);//stops the task after the lift is up

	dumpCube();//dumps the cube
	//wait1Msec(1000);//pointless
	StartTask(liftDown);//starts dropping the lift

	move(60);//moves forward towards the starting position

	while (distanceTravelled() <= irBackDistances[crateVal-1]){move(60);}//waits until the robot is five inches away from the wall

	brake();//stops five inches away from the wall
	//resetEncoders();
	resetEncoders();
	wait1Msec(800);
	turn45(true);//turns right at half power
	wait1Msec(800);

	resetEncoders();
	move(60);
	while (distanceTravelled() < 22){move(60);}

	brake();
	wait1Msec(800);
	resetEncoders();
	turn45(true);
	wait1Msec(800);
	resetEncoders();
	move(60);
	while (distanceTravelled() < rampLineUpDistance){move(60);}
	brake();

	while (!liftIsDown){}
	StopTask(liftDown);

	wait1Msec(800);
	resetEncoders();
	turn90(false);//turns right at half power

	wait1Msec(800);

	ClearTimer(T4);
	resetEncoders();
	moveForward(-100);
	while(distanceTravelled() <= UPRAMPDIST && time1[T4] <= UPRAMPTIME){wait1Msec(1);}
	brake();

	if (defend_ramp)
	{
		brake();
		wait1Msec(100);
		turn90(false);
		brake();
		moveForward(-100);
		wait1Msec(500);
		brake();
	}
/* //**OLD RAMP DEFENSE CODE: DO NOT USE UNLESS CIRCUMSTANCES ARE DIRE**
	brake();
	wait1Msec(100);
	swingLeft(false);
	wait1Msec(swingTime);
	brake();
	moveForward(-100);
	wait1Msec(500);
	brake();
	*/
	resetEncoders();//This  following loop counters any pushes that the robot may encounter
	//int currentCheck = 0;
	while (true){ //condition was "time1[T1] < 29500"; changed by Zach. It will continue to run until the field stops automatically.
		if ((nMotorEncoder[Left]+nMotorEncoder[Right])/2 <= -0.5*in && (nMotorEncoder[Left]+nMotorEncoder[Right])/2 > -2*in){
			moveForward(30);
		}
		if ((nMotorEncoder[Left]+nMotorEncoder[Right])/2 >= 0.5*in && (nMotorEncoder[Left]+nMotorEncoder[Right])/2 < 2*in){
			moveForward(-30);
		}
		if ((nMotorEncoder[Left]+nMotorEncoder[Right])/2 >= 2*in){
			moveForward(-100);
		}
		if ((nMotorEncoder[Left]+nMotorEncoder[Right])/2 <= -2*in){
			moveForward(100);
		}
		if ((nMotorEncoder[Left]+nMotorEncoder[Right])/2 > -0.5*in){
			if ((nMotorEncoder[Left]+nMotorEncoder[Right])/2 < 0.5*in){
				brake();
			}
		}
	}
	//the following two lines of code will never be executed
	brake();
	initializeRobot();
}
