#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S3,     infared,        sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Right,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     Lift1,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Lift2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     Sweep,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.


void initializeRobot()
{
	servo[bucket] = 130;
}

task main()
{
  initializeRobot();

  waitForStart();
  float in = 114.649682;
  float deg = 16.5;
  int ir = 0;

	//check beacon 1
  //line up with beacon 1
  nMotorEncoder[Left] = 0;
  while(abs(nMotorEncoder[Left]) < 36*in)//HAS TO BE ADJUSTED
  {
  	motor[Left] = 100;
   	motor[Right] = 100;
  }
  motor[Left] = 0;
  motor[Right] = 0;
  wait1Msec(300);
  //check for beacon 1
  if (SensorValue[infared] == 5)
  {
    ir = 1;//beacon is on goal 1
  }
  if (ir == 0)//check beacon 2
  {
    //line up with beacon 2
    nMotorEncoder[Left] = 0;
    while(abs(nMotorEncoder[Left]) < 10*in)
    {
    	motor[Left] = 100;
    	motor[Right] = 100;
    }
    motor[Left] = 0;
    motor[Right] = 0;
    wait1Msec(300);
    //check for beacon 2
    if (SensorValue[infared] == 5)
    {
      ir = 2;//beacon is on goal 2
    }
  }
  if (ir == 0)// check beacon 3
  {
    //line up with beacon 3
    nMotorEncoder[Left] = 0;
    while(abs(nMotorEncoder[Left]) < 23*in)
    {
    	motor[Left] = 100;
    	motor[Right] = 100;
    }
    motor[Left] = 0;
    motor[Right] = 0;
    wait1Msec(300);
    //check for beacon 3
    if (SensorValue[infared] == 5)
    {
      ir = 3;//beacon is on goal 3
    }
  }
  if (ir == 0)//check beacon 4
  {
    //line up with beacon 4
    nMotorEncoder[Left] = 0;
    while(abs(nMotorEncoder[Left]) < 10*in)
    {
    	motor[Left] = 100;
    	motor[Right] = 100;
    }
    motor[Left] = 0;
    motor[Right] = 0;
    wait1Msec(300);
    //check for beacon 4
    if (SensorValue[infared] == 5)
    {
      ir = 4;//beacon is on goal 4
    }
  }

  //align with goal
  //goal 1 and 2 are already aligned
  if (ir == 3|| ir == 4)//align 3 or 4
  {
    nMotorEncoder[Left] = 0;
    while(abs(nMotorEncoder[Left]) < 2*in)//opposite direction of robot
    {
      motor[Left] = -70;
      motor[Right] = -70;
    }
    motor[Left] = 0;
    motor[Right] = 0;
    wait1Msec(300);
  }
  if (ir == 0)//if ir was not found, align with goal 1
  {
    nMotorEncoder[Left] = 0;
    while(abs(nMotorEncoder[Left]) < 43*in)
    {
      motor[Left] = -100;
      motor[Right] = -100;
    }
    motor[Left] = 0;
    motor[Right] = 0;
    wait1Msec(300);
  }

  //dump cube
  motor[Lift1] = 100;
  motor[Lift2] = 100;
  wait1Msec(2100);
  motor[Lift1] = 0;
  motor[Lift2] = 0;
  wait10Msec(5);
  servo[bucket] = 230;
  wait1Msec(1000);
  servo[bucket] = 125;
  wait10Msec(100);
  motor[Lift1] = -100;
  motor[Lift2] = -100;
  wait1Msec(1100);
  motor[Lift1] = 0;
  motor[Lift2] = 0;

  //back up, center 18in away from end of pendulum, starting side
  if (ir == 0 || ir == 1)
  {
    nMotorEncoder[Left] = 0;
    while(abs(nMotorEncoder[Left]) < 22.5*in)
    {
   	  motor[Left] = -100;
      motor[Right] = -100;
    }
    motor[Left] = 0;
    motor[Right] = 0;
    wait1Msec(300);
  }
  if (ir == 2)
  {
    nMotorEncoder[Left] = 0;
    while(abs(nMotorEncoder[Left]) < 32.5*in)
    {
      motor[Left] = -100;
      motor[Right] = -100;
    }
    motor[Left] = 0;
    motor[Right] = 0;
    wait1Msec(300);
  }
  if (ir == 3)
  {
    nMotorEncoder[Left] = 0;
    while(abs(nMotorEncoder[Left]) < 51.5*in)
    {
      motor[Left] = -100;
      motor[Right] = -100;
    }
    motor[Left] = 0;
    motor[Right] = 0;
    wait1Msec(300);
  }
  if (ir == 4)
  {
    nMotorEncoder[Left] = 0;
    while(abs(nMotorEncoder[Left]) < 61.5*in)
    {
      motor[Left] = -100;
      motor[Right] = -100;
    }
    motor[Left] = 0;
    motor[Right] = 0;
    wait1Msec(300);
  }

  //turn right 90deg
  nMotorEncoder[Left] = 0;
  while(abs(nMotorEncoder[Left]) < 90*deg)
  {
    motor[Left] = 100;
    motor[Right] = -100;
  }
  motor[Left] = 0;
  motor[Right] = 0;
  wait1Msec(300);

  //move infront of ramp
  nMotorEncoder[Left] = 0;
  while(abs(nMotorEncoder[Left]) < 28*in)
  {
    motor[Left] = 100;
    motor[Right] = -100;
  }
  motor[Left] = 0;
  motor[Right] = 0;
  wait1Msec(300);

  //turn so back faces ramp
  nMotorEncoder[Left] = 0;
  while(abs(nMotorEncoder[Left]) < 90*deg)
  {
    motor[Left] = -100;
    motor[Right] = 100;
  }
  motor[Left] = 0;
  motor[Right] = 0;
  wait1Msec(300);

  //drive up ramp
  nMotorEncoder[Left] = 0;
  while(abs(nMotorEncoder[Left]) < 42*in)
  {
    motor[Left] = -100;
    motor[Right] = -100;
  }
  motor[Left] = 0;
  motor[Right] = 0;
  wait1Msec(300);

}
